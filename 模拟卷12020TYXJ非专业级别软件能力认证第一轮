2020TYXJ非专业级别软件能力认证第一轮（CSP-S）提高组C++语言试题试卷
考生注意事项：试题纸共有10页，满分100分，请在答题纸上作答，写在试题纸上的一律无效。不得使用任何电子设备（如计算机、计算器、手机）或查阅任何书籍资料。

单项选择（共15题，每题2分，共计30分，每题仅有一个最佳答案）
1、在bits/stdc++.h头文件下，若有定义：int a=5,b=4,c=3,b=2;则表达式pow(a,b)-pow(c,d)的值为（   ）

A． 616
B． 634
C． 1020
D． 1036


2、现有A、B、C、D四张图片，选项中描述了它们的参数。在存储图像信息空间不超过3MB的照片中，分辨率最大的是（   ）
A．分辨率1600*900,16位色
B．分辨率400*225,16位色
C．分辨率800*450,8位色
D．分辨率1250*150,16位色

3、下面是十进制数的二进制位运算算式：20^19+10&11.该算式十进制结果为（   ）
A．3
B．9
C．23
D．29


4、在下列关于计算机语言的说法中，正确的有（   ）。
A. 高级语言比汇编语言更高级，是因为它的程序的运行效率更高
B. 随着Pascal、C等高级语言的出现，机器语言和汇编语言已经退出了历史舞台
C. 高级语言程序比汇编语言程序更容易从一种计算机移植到另一种计算机上
D. C是一种面向对象的高级计算机语言

5对于二进制数x，下面哪个操作可以使该二进制数从最左边第一位开始到该数最后一个0结束（包括0）（若该数+1为2的正整数次方，则视该数最右边一位为0），这些位上所有的数码变为0？（   ）
例：x=(1001101)2，ans=(0000001)2,x=(1011111)2,ans=(0011111)2

A. x=x^(x+1)>>1
B. x&=x+1
C. x|=x+1
D. x|=x-1


6、关于排序算法，下列叙述不正确的一项是（   ）
A. 桶排序、冒泡排序、选择排序、二叉树排序都是稳定排序
B. 归并排序可以用来求逆序对
C. 平均来说插入排序算法的时间复杂度为O(n^2)。
D. 快速排序、鸡尾酒排序是对冒泡排序的一种改进变形

7、关于最短路算法，下面正确的一项是（   ）
A. floyd中不存在松弛操作
B. Bellman-Ford 是SPFA 的优化，SPFA在构造数据面前时间复杂度可能会达到O(nm)（n为点数，m为边数）
C. 堆优化的dijkstra时间复杂度为O(nlogn) （n为点数）
D. Floyd、Dijkstra、SPFA中最适合处理多源最短路径的是Dijkstra
8、已知x，y为正整数，且为二位数。现有8x≡1(mod3),7x≡2(mod4),9y≡1(mod5),4x≡2(mod6)，x的个数与y的个数的乘积为（   ）

A. 48
B. 56
C. 96
D. 104


9、下面部分代码哪个关于链式前向星存图的代码是错误的？（   ）
A
#include<bits/stdc++.h>
using namespace std;
const int maxn=300005;
int h[maxn],cnt;
struct node{int to,next;}w[maxn*2];
void add(int x,int y){w[++cnt].to=y;w[cnt].next=h[x];h[x]=cnt;}
……

B
#include<bits/stdc++.h>
using namespace std;
const int ma=2005;
struct Edge{int to,nxt;}e[10005];
int tot,head[ma];
void add(int u,int v){e[++tot]={v,head[u]};head[u]=tot;}
……

C
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e4+9,maxm=1e5+9;
int main()
{
    int n=read(),cnt=0,i,u,v;
    int p,he[maxn],ne[maxm],to[maxm],w[maxm];
for(i=1;i<n;i++)u=read(),v=read(),w[++p]=read(),w[p+1]=w[p],ne[p]=he[u],to[he[u]=p]=v,p++,ne[p]=he[v],to[he[v]=p]=u;
……

D
#include <bits/stdc++.h>
using namespace std;
int Max=1000005,cnt,head[Max];
struct node{int nxt,to,dis;}edge[Max];
void add(int from,int to,int dis){
edge[cnt]={head[from],to,dis};head[from]=cnt;}
……

10、有10个数字：1,1,1,2,2,3,3,3,3,5从这些数字选择6个以任意顺序组成一个6位数，一共有（   ）种方式。

A. 105
B. 525
C. 1050
D. 2100


11、关于图的存储，不正确的一项是（   ）
A. 邻接矩阵适合于点少边多的图，而对于边少的图，可以考虑用邻接表。
B. 若采用邻接矩阵存储图，遍历图的时间复杂度为O(n^2);若采用邻接表存储，输入的顶点信息即为顶点的编号，则时间复杂度为O(n+m); （n为点数，m为边数）
C. 邻接矩阵邻接链表是针对边的存储图方式
D. 边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息。它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。

12、关于前缀表达式、中缀表达式，正确的是（   ）
A. (a+b)*(c+d)的前缀表达式为*,+,a,b,+,c,d
B. “- 1 + 2 3”的值为-4
C. “1+5*8-55”为中缀表达式
D. 前缀表达式又被称为波兰式，计算方法是从第一位开始，如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。

13、若有说明：int a=2,*p=&a,*q=p,则以下非法的赋值语句是（   ）

A. p=q
B. *p=*q
C . a=*q;
D. q=a;


14、现在给出1,2，…，n的两个排列P1，P2，用动态规划求它们的最长公共子序列（LCS）。我们用dp[i][j]来表示第一个串的前i位，第二个串前j位LCS的长度，那么状态转移方程是（   ）
A. dp[i][j]=(P1[i]==P2[j]?max(dp[i][j],dp[i-1][j-1]+1): max(dp[i-1][j],dp[i][j-1]))
B. dp[i][j]=(P1[i]==P2[j]?max(dp[i][j],dp[i-1][j-1]): max(dp[i-1][j],dp[i][j-1]))
C. dp[i][j]=(P1[i]!=P2[j]?max(dp[i][j],dp[i-1][j-1]+1): max(dp[i-1][j],dp[i][j-1]))
D. dp[i][j]=(P1[i]!=P2[j]?max(dp[i][j],dp[i-1][j-1]): max(dp[i-1][j],dp[i][j-1]))

15、辗转经由他人唇齿  多少日夜听闻你的故事  难道这情之一字  竟连抛生死亦不可探知  听说北国的那座城池  被冬雪覆了终日  等到故人长诀渐行渐远  转眼已隔两世  谁向生而死 谁患得患失  相顾也再无多时  画中人暗自 竟心荡神痴  一滴泪氤氲满纸  挥墨描眉目 提笔勾鬓丝  寥寥几笔竟如此 夜半无人处 对月展卷时  忽然看懂这相思  落款谁提了名字
竟宁元年（前33年）正月，昭君出塞前一晚。画师跌跌撞撞地来到昭君居住的宫殿。如果再也不能相见的话，画师想着，他想给昭君留下些什么。他想把他的画笔送给昭君。昭君的宫殿里有N个房间，有N-1条道路连接这些房间。画师现在在宫殿的入口大厅S房间，他依稀记得，昭君的房间在T号。窗外，风雨大作，宫内忽暗忽明，一个人影也没有。画家走进晦暗的通道，每条通道里的墙壁上都画有若干片枫叶，这是之前昭君让画师画的。昭君说，她特别喜欢秋天，尤其喜欢秋天的枫叶。通道内晦暗无比，画师想点亮通道内备好的蜡烛，他记得昭君有个习惯，每个通道内的蜡烛数量就是墙上枫叶的数量。昭君若想点燃一条通道内的蜡烛，就会全部点燃，此时昭君认为这条通道已被点亮，并且不会再点亮任何枫叶数少于这条通道的通道。这应该是最后一次来到这个地方了，画师想着，他要按昭君的习惯，走到昭君的房间。
现在画师想知道，他从宫殿大厅S走到昭君房间T，最多可以点亮多少通道。
下面的输入中，第一行一个数N，表示宫殿房间数量。接下来有N-1行，每行三个数ui​,vi​,leafi​，表示u,v之间有一条通道，通道上画有leafi​片枫叶。接下来一个数M。最后M行，每行两个数Si​,Ti​
20
1 2 1
1 3 3
2 4 5
1 5 1
5 6 5
1 7 5
1 8 4
7 9 1
8 10 2
1 11 1
2 12 5
3 13 1
3 14 3
3 15 3
10 16 1
5 17 1
12 18 5
7 19 4
7 20 5
10
10 3
17 16
11 9
4 6
16 17
11 16
11 11
2 1
那么最多能够点亮的通道数的和的是（   ）。

A. 15 
B. 16 
C. 18 
D. 20


阅读程序
第一部分  阅读理解 共35分
注：程序输入不超过数组或字符串定义的范围，判断题正确填√，错误填×



A
 
（1.5分）若n乘以a数组中最大的数小于100000，则tmp小于100000（   ）
（1.5分）tmp>0（   ）
（1分）若将第11行”ans++”改为” ans+=sum-tot”，程序运行结束时ans等于a数组所有元素和的相反数（   ）
（1分）若输入的a数组是一个严格单调递增的数列，则程序运行结束时ans=1（   ）
5、（3分）本代码时间复杂度为（   ）
A. O(n) 
B. O(n2) 
C. O(nlogn) 
D. O(n√n)

6、（1分）程序运行结束时a数组所有元素和大于等于tmp（   ）
7、（1.5分）若将第11行 ”<” 改为 ”<=” ，程序输出结果不改变（   ）
8、（1分）若第10行将 ”i+1” 改为 ” i” ，sum与原程序相比不改变（   ）
9、（1.5分）若第8行将 ”<=n” 改为 ” <n” ， 程序输出结果不改变（   ）
10、（1分）若将第11行第二个 “；” 改为 ” ，” ， 程序输出结果不改变（   ）


B
下面的程序用ST表解决静态区间最大值问题
题目：给定一个长度为 N 的数列，和 M 次询问，求出每一次询问的区间内数字的最大值。
 
 
1、（2分）本代码运用了前缀和和倍增的思想（   ）
2、（1分）解决本问题可采用线段树（   ）
3、（1分）解决本问题可采用树状数组（   ）
4、（4分）本代码时间复杂度为（   ）

A. O(n) 
B. O(n2) 
C. O(nlogn) 
D. O(n√n)

5、（2分）在ST表中，预处理时间复杂度为O(n)，查询最值时间复杂度为O(1) （   ）
6、（1分）若仅将”//1”改为下列代码，运行速度会加快（   ）
 
7、（1分）若仅将”//2”改为”std::ios::sync_with_stdio(false);” 运行速度会加快（   ）


C
 
 
1、（4分）该算法复杂度为（   ）
A. O（la*lb）B. O（la+lb）C. O（log（la*lb））D. O（log（la+lb））
2、（2分）除最后一行外，其余所有数字小于等于la/lb+1（   ）
3、（3分）
若输入：
ABABABC
ABA
则输出：
1
3
0 1 0
（   ）

第二部分  完形填空 共35分

D（电梯）（第一空2分，最后一空3分，其余空3.5分）
大楼的每一层楼都可以停电梯，而且第i层楼 (1≤i≤N)上有一个数字Ki​(0≤Ki​≤N)。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：Ki​=3, 3 ,1 ,2 ,5（i=1,2,3,4,5）在1楼，按“上”可以到4楼，按“下”是不起作用的那么，从A楼到B楼至少要按几次按钮呢？
输入第一行为3个数，表示N,A,B(1≤N≤200, 1≤A,B≤N)。第二行为N个非负整数表示Ki​。
输出最少按键次数,若无法到达，则输出-1。

#include<bits/stdc++.h>
using namespace std;
int n,a,b,to[205];
bool vis[205];     1     ;
struct node{int id,step;}x;//id表示楼层号，step表示按钮次数
int main()
{
	scanf("%d%d%d",&n,&a,&b);
	for(int i=1;i<=n;i++) scanf("%d",&to[i]);
	     2     ;
	while(q.size())
	{
		x=q.front();q.pop();
		if(x.id==b) break;
		if(     3     )
		{
			q.push((node){x.id+to[x.id],x.step+1});
			     4     ;
		}
		if(x.id-to[x.id]>=1&&!vis[x.id-to[x.id]])
		{
			     5     ;
			vis[x.id-to[x.id]]=1;
		}
	}
	if(x.id==b) printf("%d",     6     );
	else printf("-1");
	return 0;
}

1、1处应填（   ）
A. queue<node> q
B. queue<int> q
C. queue<bool> q
D. queue<struct> q
2、2处应填（   ）
A. q.push({a,0});
B. q.push((node){a,0});
C. q.push((node){a,1});
D. q.push((node){0,a});
3、3处应填（   ）
A. vis[x.id]=1;
B. vis[x.id]=1;
C. vis[x.id+to[x.id]]=0;
D. vis[x.id+to[x.id]]=1;
4、4处应填（   ）
A. x.id+to[x.id]<=n&&vis[x.id+to[x.id]]
B. x.id+to[x.id]<=n&&!vis[x.id+to[x.id]]
C. x.id+to[x.id]>=1&&vis[x.id+to[x.id]]
D. x.id+to[x.id]>=1&&!vis[x.id+to[x.id]]
5、5处应填（   ）
A. q.push((node){x.id-to[x.id]+1,x.step+1});
B. q.push((node){x.id-to[x.id]+1,x.step});
C. q.push((node){x.id-to[x.id],x.step});
D. q.push((node){x.id-to[x.id],x.step+1});
6、6处应填（   ）
A. x.step-1
B. x.step+1
C. x.step
D. step

E（火柴）(第一空2分，其余空3.5分)
九条可怜有两盒火柴，每盒装有 n（1≤n≤105 ）根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为：∑(ai​−bi​)2.其中 ai​ （0≤ ai​ <231）表示第一列火柴中第 i 个火柴的高度， bi​ 表示第二列火柴中第 i 个火柴的高度。每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？ 
输入格式
共三行，第一行包含一个整数 n，表示每盒中火柴的数目。
第二行有 n 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。
第三行有 n 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。
本题采用树状数组求逆序对实现
#include<bits/stdc++.h>
using namespace std;
const int Max=1000010,mod=99999997;
int n,ans,c[Max],t[Max];     1     ;
int que(int k){int ans=0;while(k>0)    2    ;return ans;}
void add(int k){while(k<=n)    3    ;}
int main()
{
	cin>>n;
    for(int i=1;i<=n;i++)a[i].first=read(),a[i].second=i;
    for(int i=1;i<=n;i++)b[i].first=read(),b[i].second=i;
    sort(a+1,a+n+1);sort(b+1,b+n+1);
    for(int i=1;i<=n;i++)    4    ;
    for(int i=1;i<=n;i++)    5    ;
    cout<<ans;
	return 0;
}
1、1处应填（   ）
A. Pair<int,int> a[Max],b[Max];
B. Pair a[Max],b[Max];
C. pair<int,int> a[Max],b[Max];
D. pair a[Max],b[Max];
2、2处应填（   ）
A. ans+=t[k],k+=k&-k
B. ans+=t[k],k+=k|-k
C. ans+=t[k],k-=k|-k
D. ans+=t[k],k-=k&-k
3、3处应填（   ）
A. ++t[k],k-=k&-k
B. --t[k],k-=k&-k
C. --t[k],k+=k&-k
D. ++t[k],k+=k&-k
4、4处应填（   ）
A. c[a[i].first]=b[i].first;
B. c[a[i].second]=b[i].second;
C. c[a[i].one]=b[i].one;
D. c[a[i].two]=b[i].two;
5、5处应填（   ）
A. ans+=que(n-c[i]+1),add(n-c[i]+1),ans%=mod;
B. ans+=que(n-c[i]),add(n-c[i]+1),ans%=mod;
C. ans+=que(n-c[i]),add(n-c[i]),ans%=mod;
D. ans+=que(n-c[i]+1),add(n-c[i]),ans%=mod;

答题纸
 
1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	   
															 
  
A1	A2	A3	A4	选A5	A6	A7	A8	A9	A10	   
										 
  
B1	B2	B3	选B4	B5	B6	B7	选C1	C2	C3	   
										 
  
D1	D2	D3	D4	D5	D6	E1	E2	E3	E4	E5	   
											 
答案
ACCDA ACADB CDDAB
A: √×××B√√√√√
B:  ×√√C××√
C:  B×××
D:  ABBDDC
E:  CADBB


1 A  625-9
2C
（下面计算在考场中估算即可）3MB=3145728B
A:存储图像信息空间20340000B,过大，舍去B:分辨率90000，存储图像信息空间1440000
C:分辨率360000，存储图像信息空间2880000D:分辨率187500，存储图像信息空间3000000
3【NOIP2007普及组】
【答案】C
【分析】高级语言比汇编语言更高级，是针对计算机语言的发展阶段讲的。人们使用高级语言编写程序，要比汇编语言容易得多。优秀的程序设计人员用汇编语言编写的程序，往往效率更高一些。
机器语言和汇编语言并没有退出历史舞台。一些和硬件操作（特别是设计外部设备的操作）关系十分密切的程序，往往还需要用汇编语言编写。
面向对象必须以类class为基础，以类为程序基本单位而C语言是以函数为程序的基本单位，没有类的概念，所以不是面向对。C语言应属于结构化程序设计模式，即使用顺序分支循环三种结构完成所有事情，以过程(在C语言中是函数)为基本单位，因此它是面向过程的
4 D
运算顺序20^((19+10)&11)
29&11=(11101)2&(01011)2=(01011)2
(01011)2&(20)10=(01011)2&(10100)2=(11101)2=(29)10
5A
Bx&=x+1将右边连续的1变为0 Cx|=x+1将右边第一个0变为1 Dx|=x-1将右边连续的0变为1
6 A  鸡尾酒排序,即双向的冒泡排序  选择排序是不稳定排序算法
7C  SPFA是Bellman-Ford的优化 最适合处理多源最短路径的是Floyd
8A
方程1:2 5 8 11 14 ……方程2:2 6 10 14 ……，所以x=2,14，……（每次+12）又有x是为二位数，所以x=14 26 38 50 62 74 86 98共8个
方程1:4 9……方程2:2 5 ……，所以x=14,29,44，……（每次+15）所以x=14 29 44 59 74 89 共6个
9D  cnt++！为防止歧义，特意设置了变量int做数组大小的错误（Max）
10B  可重集合排列数：c=n！/（（n-r）！n1！n2！…nm！）
11C  C邻接矩阵邻接链表是针对顶点的存储图方式，边集数组是针对边的存储图方式
12D  题中为后缀表达式计算方法
13D
a是整型数，int *p,*q定义了指针，p，q是指向整型的指针p取得a的地址，而q取得p的地址，p，q是指针（地址），而*p和*q是这个指针指向的整型数值（存放在地址的值）
A把q的地址赋给p，则p、q都指向2  B把q中数据给p
C把q中数据给a  D a中数据是2，不能够给一个地址。
14A
15B  考察每条路径的求最长不下降子序列的dp…

A  √×××B√√√√√
2：大于等于
3：负的（n-1）a[1]+(n-2)a[2]+…
4：0
B（ST表）×√√C××√
1：不关前缀和什么事
5：预处理与总时间复杂度都为nlogn
6：还要改=read（）
C（KMP ）B××
1：每次位置指针i++时，失配指针j至多增加一次，所以j至多增加len次，从而至多减少len次，所以就是Θ(lenN​+lenM​)=Θ(N+M)的
2：胡扯！没有关系！<la-lb
3：应输出1
3
0 0 1
D  ABBDDC
#include<bits/stdc++.h>
using namespace std;
int n,a,b,to[205];
bool vis[205];
struct node{int id,step;}x;//id表示楼层号，step表示按钮次数
queue<node> q;
int main()
{
	scanf("%d%d%d",&n,&a,&b);
	for(int i=1;i<=n;i++) scanf("%d",&to[i]);
	q.push((node){a,0});
	while(q.size())
	{
		x=q.front();q.pop();
		if(x.id==b) break;
		if(x.id+to[x.id]<=n&&!vis[x.id+to[x.id]])
		{
			q.push((node){x.id+to[x.id],x.step+1});
			vis[x.id+to[x.id]]=1;
		}
		if(x.id-to[x.id]>=1&&!vis[x.id-to[x.id]])
		{
			q.push((node){x.id-to[x.id],x.step+1});
			vis[x.id-to[x.id]]=1;
		}
	}
	if(x.id==b) printf("%d",x.step);
	else printf("-1");
	return 0;
}

E  CADBB

#include<bits/stdc++.h>
using namespace std;
const int Max=1000010,mod=99999997;
int n,ans,c[Max],t[Max];
pair<int,int> a[Max],b[Max];
int que(int k){int ans=0;while(k>0)ans+=t[k],k-=k&-k;return ans;}
void add(int k){while(k<=n)++t[k],k+=k&-k;}
int main()
{
	cin>>n;
    for(int i=1;i<=n;i++)a[i].first=read(),a[i].second=i;
    for(int i=1;i<=n;i++)b[i].first=read(),b[i].second=i;
    sort(a+1,a+n+1);sort(b+1,b+n+1);
    for(int i=1;i<=n;i++)c[a[i].second]=b[i].second;
    for(int i=1;i<=n;i++)ans+=que(n-c[i]),add(n-c[i]+1),ans%=mod;
    cout<<ans;
	return 0;
}


知识点溯源
一般认为，较典型的面向对象语言有：
simula 67，支持单继承和一定含义的多态和部分动态绑定；
Small talk支持单继承、多态和动态绑定；
EIFFEL，支持多继承、多态和动态绑定；
C++，支持多继承、多态和部分动态绑定。
Java，支持单继承、多态和部分动态绑定。
https://wenku.baidu.com/view/b2c1d22a6137ee06eef918bf.html
